import RPi.GPIO as GPIO
import time

# test shift register code, problem 2, referenced module 5 last page

"""
GPIO.setmode(GPIO.BCM)
serialPin, latchPin, clockPin = 23, 24, 25

GPIO.setup(serialPin, GPIO.OUT)
GPIO.setup(latchPin, GPIO.OUT, initial=0)
GPIO.setup(clockPin, GPIO.OUT, initial=0)

def ping(p):
    GPIO.output(p, 1)
    time.sleep(0)
    GPIO.output(p, 0)

def shiftByte(b):
    for i in range(8):
        GPIO.output(serialPin, b & (1 << i))
        ping(clockPin)
    ping(latchPin)

try:
    while 1:
        for i in range(2**8):
            shiftByte(i)
            time.sleep(0.5)
except KeyboardInterrupt:
    GPIO.cleanup()
"""

# referenced module 2, page 86 for classes and objects example
class Shifter:
    def __init__(self, serialPin, latchPin, clockPin): # instantiation
        # constructor
        self.serialPin = serialPin
        self.latchPin = latchPin
        self.clockPin = clockPin

        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.serialPin, GPIO.OUT)
        GPIO.setup(self.latchPin, GPIO.OUT, initial=0)
        GPIO.setup(self.clockPin, GPIO.OUT, initial=0)

# referenced module 2, page 92, private vs public class variables/methods
    def __ping(self, p): # private
        GPIO.output(p, 1)
        time.sleep(0)
        GPIO.output(p, 0)

    def shiftByte(self, b): # public
        for i in range(8):
            GPIO.output(self.serialPin, b & (1 << i))
            self.__ping(self.clockPin)
        self.__ping(self.latchPin)



import threading
import random

class Bug:
    def __init__(self, timestep=0.1, x=3, isWrapOn=False):
        self.timestep = timestep       
        self.x = x                     # 0-7
        self.isWrapOn = isWrapOn       
        self.__shifter = Shifter(23, 24, 25)  # private 
        self.__running = False         
        self.__thread = None           

    def __lightningbug(self):
        leds = 8
        while self.__running:
            led_pattern = 1 << self.x
            self.__shifter.shiftByte(led_pattern)

            step = random.choice([-1, 1])
            new_x = self.x + step

            if self.isWrapOn:
                self.x = new_x % leds # leveraged chatgpt to wrap around with % for pos and neg
            else:
                if new_x < 0:
                    self.x = 0 # left bound
                elif new_x >= leds:
                    self.x = leds - 1 # right bound
                else:
                    self.x = new_x

            time.sleep(self.timestep)

    def start(self):
        if not self.__running:
            self.__running = True
            self.__thread = threading.Thread(target=self.__lightningbug, daemon=True) # referenced module 6 page 7 to run function concurrently
            self.__thread.start() # start thread to run function

    def stop(self):
        self.__running = False
        if self.__thread:
            self.__thread.join() # module 6, "force calling process to wait for the thread to end before continuing"
        self.__shifter.shiftByte(0)



# Pin setup
s1 = 17 
s2 = 27 
s3 = 22 

GPIO.setmode(GPIO.BCM)
GPIO.setup(s1, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(s2, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(s3, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# Create Bug instance
bug = Bug()  # default timestep=0.1, x=3, isWrapOn=False

s1_prev = GPIO.input(s1)
s2_prev = GPIO.input(s2)

try:
    while True:
        s1_new = GPIO.input(s1)
        s2_new = GPIO.input(s2)
        s3_new = GPIO.input(s3)

        # --- s1: Turn bug on/off ---
        if s1_new != s1_prev:  # detect change
            if s1_new == GPIO.HIGH:
                print("Bug started")
                bug.start()
            else:
                print("Bug stopped")
                bug.stop()
            s1_prev = s1_new

        # --- s2: Toggle wrapping mode ---
        if s2_new != s2_prev:
            bug.isWrapOn = not bug.isWrapOn
            print(f"Wrap mode: {'ON' if bug.isWrapOn else 'OFF'}")
            s2_prev = s2_new

        # --- s3: Change speed ---
        if s3_new:
            bug.timestep = 0.1 / 3
        else:
            bug.timestep = 0.1

        time.sleep(0.05)

except KeyboardInterrupt:
    print("\nExiting...")
    bug.stop()
    GPIO.cleanup()

