#setup from module 4
import RPi.GPIO as GPIO
import time
import math

# 1. The time.time() function returns the current system time in seconds. Using this function
# together with PWM control over a GPIO pin, actuate a single LED with brightness B given by
# B = (sin(2πƒt)) 2 with a frequency of f=0.2 Hz.

"""
f = 0.2 #frequency
f_base = 500 #base frequency
GPIO.setmode(GPIO.BCM)

#blink with pwm module 4
pi_pin = 4   
GPIO.setup(pi_pin, GPIO.OUT)
pwm = GPIO.PWM(pi_pin, f_base)
pwm.start(0)

try:
    while True:
        t = time.time()
        B = math.sin(2 * math.pi * f * t)**2 
        pwm.ChangeDutyCycle(B * 100)
except KeyboardInterrupt:
    pass
finally:
    pwm.stop()
    GPIO.cleanup()
"""

# 2. Modify your code to simultaneously actuate a second LED adjacent to the first LED, with brightness
# following B = (sin(2πƒt – φ))2 , where φ = π/11 rad.

"""
f = 0.2            
f_base = 500      
phi = math.pi / 11 

GPIO.setmode(GPIO.BCM)

p1 = 4
p2 = 17

GPIO.setup(p1, GPIO.OUT)
GPIO.setup(p2, GPIO.OUT)
pwm1 = GPIO.PWM(p1, f_base)
pwm2 = GPIO.PWM(p2, f_base)
pwm1.start(0)
pwm2.start(0)

try:
    while True:
        t = time.time()  

        B1 = math.sin(2 * math.pi * f * t) ** 2
        pwm1.ChangeDutyCycle(B1 * 100)

        B2 = math.sin(2 * math.pi * f * t - phi) ** 2
        pwm2.ChangeDutyCycle(B2 * 100)

except KeyboardInterrupt:
    pass
finally:
    pwm1.stop()
    pwm2.stop()
    GPIO.cleanup()
"""

# Wave of light with button

GPIO.setmode(GPIO.BCM)

pi_pins = [4, 17, 27, 22, 10, 9, 11, 5, 6, 13]
button = 21

for pin in pi_pins:
	GPIO.setup(pin, GPIO.OUT)

# threaded call back example 
GPIO.setup(button, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

f = 0.2            
f_base = 500      
phi = math.pi / 11 
direction = 1 

pwms = []
for pin in pi_pins:
    pwm = GPIO.PWM(pin, f_base)
    pwm.start(0)
    pwms.append(pwm)

# leveraged ChatGPT to explain direction variable to reverse LED flow
def button_press (pin):
	global direction
	direction *= -1

#threaded call back example
GPIO.add_event_detect(button, GPIO.RISING, callback=button_press, bouncetime=100)

#exception handling moduel
try:
	while True:
		t = time.time()

		i = 0
		for pwm in pwms:
		    B = math.sin(2 * math.pi * f * t - direction * i * phi) ** 2
		    pwm.ChangeDutyCycle(B * 100)
		    i += 1

#reference from add exception handling module
except KeyboardInterrupt: #if user hits ctrl-C
	print('\nExiting')
except Exception as e: #catch all other errors
	print('\n', e)

#learned from Chat GPT that using finally ensures cleanup always runs, even after errors
finally:
    GPIO.cleanup()



